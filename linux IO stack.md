    https://muyuuuu.github.io/2020/03/16/multi-process-thread/
# 进程、线程
    进程是cpu调度和资源分配的单位，是一个程序的一次执行
    线程是cpu调度和分派的基本单位，它可以和同一进程下的其他线程共享全部资源，线程有进程创建，寄生在进程身上
    
# 上下文切换
    https://muyuuuu.github.io/2021/04/16/CPU-context-switch/
    cpu寄存器是cpu内置的容量小、但速度极快的内存
    程序计数器是用来存储cpu正在执行的指令位置、或者即将执行的下一条指令位置

    cpu上下文切换：
    上下文切换即先把前一个任务的cpu的上下文(cpu寄存器和程序计数器)保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，
    最后再跳转到程序计数器所指的新位置，运行新任务。保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。

    cpu上下文切换分为几种场景：进程上下文切换、线程上下文切换、中断上下文切换、系统调用上下文切换
    
    linux按照特权登记，把进程的运行空间分为内核空间和用户空间，分别对应cpu特权登记的ring0和ring3：
        内核空间(ring0)：具有最高权限，可以直接访问所有资源；
        用户空间(ring3)：只能访问受限资源，不能直接访问内存等硬件资源，必须通过系统调用陷入到内核中，才能访问这些特权资源。

    进程即可以在用户空间运行，又可以在内核空间运行。在用户空间运行时，被称为进程的用户态，而陷入内核空间运行时，被称为进程的内核态。

    因为特权指令只能在内核模式下运行，所以无法在用户模式下运行特权命令，只能在用户模式下发出特权指令的系统调用，此时用户程序暂停，转换为内核模式执行系
    统调用，得到结果反馈给用户，在转换为用户模式，进程继续执行。
    系统调用的过程，通常称为特权模式切换，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。


# IO栈
    https://bbs.huaweicloud.com/blogs/detail/291911
    linux系统中，传统的访问方式是通过write()和read()两个系统调用实现。

    linux存储系统的IO栈，

## read
    read系统调用读取一块数据的时候，如果这块数据已经存在于用户进程的页内存中，就直接从内存中读取数据。如果数据不存在页内存中，则先将数据从磁盘加载到
    内核空间的读缓存中，再从读缓存拷贝到用户进程的页内存中

    基于传统的IO读取方式，read系统调用出发了2次上下文切换，1次DMA拷贝和1次CPU拷贝
    1.用户进程通过read()函数向kernel发起system call，上下文从user space切换为kernel space
    2.CPU利用DMA控制器将数据从磁盘读拷贝到kernel space的读缓冲区
    3.CPU 将读缓冲区中的数据拷贝到user space的用户缓冲区
    4.上下文从kernel space切换回用户态，read调用执行返回

## write
    当应用程序准备好数据，执行write系统调用发送数据时，先将数据从用户进行页内存拷贝到内核文件系统或网络缓冲区，然后再将缓冲区的数据拷贝到磁盘或者网卡
    

## direct IO VS buffered IO
    Directed IO是指绕过内核文件系统的缓存，直接访问通用块层的IO请求
    Buffered IO是指使用了内核文件系统缓存的IO请求

## vfs
    https://blog.51cto.com/u_15075521/4566697
    https://blog.csdn.net/jinking01/article/details/90669534
    http://blog.chinaunix.net/uid-31403813-id-5754159.html
    vfs是一个内核软件层，在具体的文件系统之上抽象的一层。用来处理与posix文件系统相关的系统调用，变现为能够为各种文件系统提供统一的访问
    接口，能使上层应用使用统一的接口访问不同的文件系统。
    
    用户glibc文件操作接口 -> 操作系统接管并转为系统调用 -> vfs层接受此调用，并转给对应文件系统、给定设备的操作

    https://www.cnblogs.com/linux-xin/p/8126999.html
    vfs统一文件模型，此模型是一个标准，各种具体文件系统的实现必须以此模型定义的各种概念来实现。
    superblock：存储文件系统的基本信息，如文件系统的类型，大小，状态即其他元数据相关的信息(元元数据)
    inode-> index node：文件元数据信息，存储与底层存储介质当中，文件大小、属主、各种time、权限block位置等，stat命令可以查看，
    但inode不包含文件名及文件在整个文件系统目录树种的位置，这两个信息有dentry提供。
    directry entry->dentry：纯粹的一个内存结构，dentry包含了文件名及文件对应的inode号，目录/文件名称对应的inode链接关系，实现文件系统
    树状层次结构，动态生成并被缓存
    file：文件对象是打开一个具体文件之后创建的一个内存数据结构，内容包括各种文件打开的flag、mode、文件名称、当前偏移等
    每个打开的文件对于用户来说有一个文件描述符，也就是VFS抽象的file object，file object指向一个dentry，dentry指向新的
    或一个inode，inode最终代表一个具体存储设备上的数据。

    目录文件的内容即是该目录下的文件的名字和inode号，目录的内容即像一张表，记录文件名和其对应的inode号的映射关系。

    表面上，用户通过文件名打开文件，实际系统内部分为三步：
    1）通过dentry项，找到这个文件名对应的inode号
    2）通过inode号，获取inode信息
    3）通过inode信息，找到文件数据所在的blcok，从而读出数据

    http://blog.chinaunix.net/uid-31403813-id-5754159.html
    http://mp.ofweek.com/it/a356714050127
    https://codefine.site/2593.html

    奇犽云存储公众号： https://mp.weixin.qq.com/s/IrZF9lWweEs1rhxuvMUCKA
    IO 从用户态走系统调用进到内核，内核的路径：VFS → 文件系统 → 块层 → SCSI 层
    vfs：把所有文件系统的共性抽象出来，比如file、inode、dentry等结构体，针对这些结构体抽象出通用api，而具体的文件系统根据这些
    api去进行具体的实现即可，因此vfs的作用总结：为上层提供抽象统一的操作接口，在IO路径上切换不同的文件系统
    文件系统：文件系统管理的是一个线性的存储空间，负责把用户看到的文件，按照文件系统自己定义的规则存储到块设备上，核心是将文件的虚拟
    空间映射到实际的线性块设备
    块层：真实硬件上层的一层抽象，屏蔽不同的硬件驱动，使块层看起来像是一个线性的存储空间。块层主要是IO调度的优化，尽可能批量收集IO
    聚合下发，让IO尽可能的顺序，合并IO请求减少IO次数等等，主要做一些IO调度策略的优化。
    SCSI层：硬件驱动，负责和磁盘硬件做转换，IO交给SCSI层后，就能顺利到达磁盘设备。

## pagecache
    奇犽云存储公众号： https://mp.weixin.qq.com/s/IrZF9lWweEs1rhxuvMUCKA
    pagechache发生在文件系统层，通常确保数据裸盘有两种方式：
    1）writeback回刷数据的方式：write调用+sync调用；
    2）DirectIO直刷数据的方式，不走文件系统的page cache；

## 块设备读写流程
    https://blog.csdn.net/mbh_1991/article/details/9455113
    https://baijiahao.baidu.com/s?id=1636290712522115001&wfr=spider&for=pc
    
    linux当中磁盘设备基于一个名为bdev的伪文件系统来管理，位于vfs下，与ext4、xfs位置相同。

## 软链 vs 硬链
    软链仅仅是

## 